@startuml StatePattern

class Game {
    - currentGame:GameState
    + setState(GameState) : void
    + StartGame()
    + GameOver()
    + FinalSecondsofGame()
}

interface Start { 
    +StartGame()
    
}
interface Almost { 
    
    +FinalSecondsofGame()
    
}
interface Finish { 
    
    +GameOver()
}

class BeginGame implements Start{ 
    -Game currGame
    +StartGame()
   
}

class AlmostDoneGame implements Almost{
    -Game currGame
    +FinalSecondsofGame()
   
}

class FinshedGame implements Finish{
    -Game currGame
   
    +GameOver()
}

Game *-- Start
Game *-- Almost
Game *-- Finish
@enduml
/*the states in World are the ones that determine how the game plays out
ex: StartGame will have currentState.Startgame
every state has to implement interface but some functions
aren't used in every state like when game is finished, you can't go to final seconds of the game,
 we could have multiple interfaces to apply interface segregation which is a part of SOLID principles
 */